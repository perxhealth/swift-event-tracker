# CLAUDE.md

This file provides guidance to Claude Code (claude.ai/code) when working with code in this repository.

## Common Development Commands

### Building and Testing
```bash
# Build the project
swift build -v

# Run all tests
swift test -v

# Run tests for a specific module
swift test --filter TrackerTests
swift test --filter SwiftAnalyticsTrackingTests
swift test --filter SwiftAnalyticsKitTrackingTests
```

### Mock Generation
The project uses Sourcery for generating mocks. To regenerate mocks:
```bash
# Generate mocks for Tracker module
./Scripts/generate_mocks.sh generate --target=Tracker --output=Sources/TrackerTesting/mocks/Tracker_mocks.generated.swift
```

### Documentation
Documentation is generated using Swift DocC and deployed to GitHub Pages:
```bash
# Generate documentation locally
swift package generate-documentation
```

## Architecture Overview

SwiftEventTracker implements a protocol-oriented, adapter-based architecture that decouples event tracking logic from specific analytics SDK implementations.

### Core Components

1. **EventTracker** (`Sources/Tracker/EventTracker.swift`): Central coordinator that manages multiple service providers and routes events based on tags

2. **Protocols** (in `Sources/Tracker/protocols/`):
   - `Service`: Base protocol for all analytics providers
   - `Event`: Protocol for trackable events with tag-based filtering
   - `Screen`: Protocol for screen tracking
   - `Taggable`: Base protocol enabling tag-based conditional tracking

3. **Tag System**: Sophisticated filtering mechanism that allows:
   - Events to specify required/excluded tags
   - Service providers to declare supported tags
   - Conditional tracking based on provider capabilities
   - Common tags: `.analytics`, `.crashReporting`, `.debugging`, `.logging`

4. **AbstractProvider** (`Sources/Tracker/services/providers/AbstractProvider.swift`): Base class providing common functionality:
   - User property management
   - User ID handling
   - Tracking disabled state
   - Default implementations for optional Service methods

### Service Provider Pattern

Each analytics SDK integration follows this pattern:
1. **Service Provider**: Implements the `Service` protocol and inherits from `AbstractProvider`
2. **Service Adapter Protocol**: Defines the interface between the provider and the actual SDK
3. **Adapter Implementation**: Created by the consumer to bridge the SDK with the adapter protocol

Example flow:
```
EventTracker -> FirebaseAnalyticsServiceProvider -> FirebaseAnalyticsServiceAdapter -> Firebase SDK
```

### Module Structure

- **Tracker**: Core library with tracking logic and vendor service providers
- **TrackerTesting**: Testing utilities and mock implementations
- **SwiftAnalyticsTracking**: Integration with swift-analytics library
- **SwiftAnalyticsKitTracking**: Integration with SwiftAnalyticsKit library
- **Examples**: Reference adapter implementations for all supported providers

### Key Design Decisions

1. **No Direct SDK Dependencies**: The library doesn't depend on any analytics SDKs directly, avoiding version conflicts and reducing binary size

2. **Composable Events**: Events can be composed using operators for flexible event creation

3. **Runtime Flexibility**: Service providers can be added/removed at runtime without code changes

4. **Type Safety**: Leverages Swift's type system for compile-time safety while maintaining runtime flexibility

5. **Testing First**: Built-in mocking support through TrackerTesting module

## Working with Service Providers

When implementing new service providers:
1. Create provider class in `Sources/Tracker/services/vendor/`
2. Define adapter protocol in `Sources/Tracker/services/vendor/adapters/`
3. Inherit from `AbstractProvider` for common functionality
4. Override specific methods only when custom behavior is needed
5. Add example adapter implementation in `Examples/Sources/`

## Testing Approach

- Unit tests use mocks generated by Sourcery
- Mock generation templates in `Scripts/templates/`
- Test utilities provided in `TrackerTesting` module
- Each module has its own test target